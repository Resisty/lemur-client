package main

import (
    "testing"
    "reflect"
)

func TestNewTokenSecret(t *testing.T) {
    // This should create a new secret with no errors
    secret := NewTokenSecret()
    if secret.Value == "" {
        t.Errorf("App secret should not be empty!")
    }
    // We should only be able to have one secret
    secret2 := NewTokenSecret()
    if secret2.Value != "" {
        t.Errorf("Should not be able to create two app secrets!")
    }
}

func TestMakeToken(t *testing.T) {
    secret := NewTokenSecret()
    // We should be able to create tokens
    token1, err := secret.MakeToken("testUser", "testrbac")
    if err != nil {
        t.Errorf("Token creation should not error!")
    }
    // Tokens should be unique
    token2, _ := secret.MakeToken("testUser", "testrbac")
    if reflect.DeepEqual(token1, token2) {
        t.Errorf("Tokens should be unique even with idential inputs!")
    }
}

func TestValidateToken(t *testing.T) {
    secret := NewTokenSecret()
    token, _ := secret.MakeToken("testUser", "testrbac")
    tokenString := token.(map[string]string)["token"]
    // We should be able to validate our tokens
    if _, err := secret.ValidateToken(tokenString); err != nil {
        t.Errorf("Tokens generated by us should validate!")
    }
    // If a token's expiry has passed, it should not validate
    shortToken, _ := secret.MakeToken("testUser", "testrbac", -30)
    tokenString = shortToken.(map[string]string)["token"]
    _, err := secret.ValidateToken(tokenString)
    if err == nil {
        t.Errorf("Expired tokens should not validate!")
    }
}
